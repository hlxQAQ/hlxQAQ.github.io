[{"title":"[noip2013]货车运输","url":"/2019/04/20/noip2013-货车运输/","content":"###1.1【题目】\nA国有n座城市，编号从 1到n，城市之间有 m 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。\n\n第一行两个整数n,m，有n 座城市和 m 条道路。\n接下来 m行每行3个整数 x, y, z，表示从 x号城市到y号城市有一条限重为 z的道路。（注意： x 不等于 y，两座城市之间可能有多条道路 。）\n接下来一行有一个整数 q，表示有 q 辆货车需要运货。\n接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。\n\n每行一个整数，表示每一辆货车最大载重。如不能到达，输出-1。\n\n[洛谷 P1967][1]\n***\n\n###1.2【基本思路】\n最大生成树+ 树剖LCA\n如何用树剖求两点权值最小\n在树剖一番蹂躏之下决定改用倍增 顺便和从没写过的倍增LCA培养一下感情\n——于是思路变成了\n最大生成树+ 倍增LCA\n\n***\n\n###1.3【笔记】\n先上最大生成树模板，因为图可能不联通，于是对每一棵树都进行LCA，极值的查询即在倍增的同时维护一个最小数组，记录这段路程中的最小路径值\n\t• 查找每棵树即枚举所有端点，将每个并查集的最大祖先（f [i] = i）都进行一遍预处理\n\t• LCA时不要忘记最后比较x,y与父节点的边的权值！！！\n\t• 忘看数据范围RE出奇迹(._. )\n\t• po一下卡了很久的LCA求路径最值部分\n```\ninline int lca2(int x,int y){\n        int ans=1e7;\n        if(deep[x]>deep[y])swap(x,y);\n        for(int i=20;i>=0;i--){\n                if(deep[fa[y][i]]>=deep[x])ans=min(minn[y][i],ans),y=fa[y][i];\n                if(x==y)return ans;\n        }\n        for(int i=20;i>=0;i--){\n                if(fa[x][i]!=fa[y][i])\n                        ans=min(minn[x][i],ans),ans=min(minn[y][i],ans),\n                        x=fa[x][i],y=fa[y][i];\n        }\n        \n        return min(min(minn[x][0],minn[y][0]),ans);\n}\n```\n***\n###1.4【倍增板子】\n事实上还是第一次写倍增LCA\n于是这里po一下倍增模板及伪代码\n```\n 调用 pre_treat(begin,begin) \t//暂时不清楚和pre_treat(begin,0)有什么区别\nvoid pre_treat (int 当前节点,int 父节点)\n\tdeep[当前节点]=depe[父]+1；\n\tfa[当前节点][0]=从这里向上跳一步=他爸爸；\n\tfor ( int i=1 to 20\n\t      fa [ 当前节点 ][ i ]=fa[从这里向上跳2^(i-1)的节点][再向上跳2^(i-1)步]\n\tfor(int i=h[u]......)\n\t      v=e[i].to 枚举下一个节点\n\t      if(这节点不是他父亲)pre_treat(int 搜到的节点,int (将做爸爸的)当前节点)\n\nvoid lca(int 友人a ,int 友人b)\n\t将友人a定为深度浅的那位；\n\tfor(int i= 20 to 0\n\t       if(友人b向上跳2^i次也跳不到a的头上)\n\t\t请友人b表演向上跳；\n\t       if(可巧友人b和a跑到了同一点)\n\t\t结束；\n\t }\n\t\t//跳出该循环后，此时a与b应该在同一深度的不同节点\n\n\tfor(int i=20 to 0\n\t       if(a和b同时向上2^i个节点却未相遇)\n\t\t向上跳；\n\t }\n公共祖先即 当前友人a和b的父节点\n```\n```\nvoid pre_treat(int u,int father){\n\tdeep[u]=deep[father]+1;\n\tf[u][0]=father;\n\tfor(int i=1;i<=20;i++){\n\t\tf[u][i]=f[f[u][i-1]][i-1];\n\t}\n\tfor(int i=h[u];i;i=e[i].nex){\n\t\tint v=e[i].to;\n\t\tif(v!=father)First(v,u);\n\t}\n}\ninline int lca(int a,int b){\n\tif(deep[a]>deep[b])swap(a,b);\n\tfor(int i=20;i>=0;i--){\n\t\tif(deep[f[b][i]]>=deep[a])\n\t\t\ty=f[b][i];\n\t\tif(a==b)return a;\n\t}\n\tfor(int i=20;i>=0;i--){\n\t\tif(f[a][i]!=f[b][i])\n\t\t\tx=f[a][i],y=f[b][i];\n\t}\n\t\n\treturn f[a][0];\n}\n```\n***\n###1.5【小结】\n生成树和倍增模板+额外维护一个答案数组……quq为啥当初我就做不出来呢\n以及貌似还有kruskal重构树+LCA , 树剖+线段树 等解法\n以后要多多注意细节问题。\n```\n#include<bits/stdc++.h>\n#define N 100010\nint n,f[N],cnt,k,m,q;\nstruct play{\n\tint x,y,l;\n};play h[N];\n\nstruct play2{\n\tint fr,to,w,nex;\n};play2 e[N];\nint fa[N][30],minn[N][30],num,he[N],deep[N];\n\nusing namespace std;\n\ninline bool cmp1(play a,play b){return a.l>b.l;}\ninline int find(int x){if(x!=f[x])f[x]=find(f[x]);\treturn f[x];}\ninline void merge(int x,int y){x=find(x),y=find(y);\tf[y]=x;}\ninline void add(int x,int y,int w){\n\te[++num].nex=he[x];\n\te[num].to=y;\n\te[num].fr=x;\n\te[num].w=w;\n\the[x]=num;\n}\ninline void First(int u,int father,int fre){\n\tdeep[u]=deep[father]+1;\n\tfa[u][0]=father;\n\tminn[u][0]=fre;\n\tfor(int i=1;i<=20;i++){\n\t\tfa[u][i]=fa[fa[u][i-1]][i-1];\n\t\tminn[u][i]=min(minn[fa[u][i-1]][i-1],minn[u][i-1]);////////...\n\t}\n\tfor(int i=he[u];i;i=e[i].nex){\n\t\tint vi=e[i].to;\n\t\tif(vi!=father)fa[vi][0]=u,First(vi,u,e[i].w);\n\t}\n}\ninline int lca2(int x,int y){\n\tint ans=1e7;\n\tif(deep[x]>deep[y])swap(x,y);\n\tfor(int i=20;i>=0;i--){\n\t\tif(deep[fa[y][i]]>=deep[x])\n\t\t\tans=min(minn[y][i],ans),y=fa[y][i];\n\t\tif(x==y)return ans;\n\t}\n\tfor(int i=20;i>=0;i--){\n\t\tif(fa[x][i]!=fa[y][i])\n\t\t\tans=min(minn[x][i],ans),\n\t\t\tans=min(minn[y][i],ans),\n\t\t\tx=fa[x][i],y=fa[y][i];\n\t}\n\t\n\treturn min(min(minn[x][0],minn[y][0]),ans);\n}\ninline void lca(){\n\tscanf(\"%d\",&q);\n\twhile(q--)\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif(find(a)!=find(b))\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tc=lca2(a,b);\n\t\tif(c<=0||c>=1e7)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",c);\n\t}\n}\ninline void scs(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tcnt++;\n\t\tcin>>h[cnt].x>>h[cnt].y>>h[cnt].l;\n\t}\n\tfor(int i=1;i<=n;i++)f[i]=i;\n\tsort(h+1,h+1+m,cmp1);\n\tint tmp=min(n-1,m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(find(h[i].x)!=find(h[i].y))\n\t\t{\n\t\t\tmerge(h[i].x,h[i].y);\n\t\t\tadd(h[i].x,h[i].y,h[i].l);\n\t\t\tadd(h[i].y,h[i].x,h[i].l);\n\t\t\tk++;\n\t\t\tif(k==tmp)break;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(f[i]==i) First(i,i,1e7);\n\t}\n}\nint main(){\n\tscs();\n\tlca();\n\treturn 0;\n}\n```\n\n  [1]: https://www.luogu.org/problemnew/show/P1967","tags":["noip","LCA","倍增","最小生成树"]},{"title":"RQM算法","url":"/2019/03/10/RQM算法/","content":"### 定义\nRMQ (Range Minimum/Maximum Query)问题是求区间最值的问题。\n***\n### 主要方法   `均为在线算法`\n1、朴素（即搜索），O(n)-O(qn) \n2、线段树，O(n)-O(qlogn) \n3、ST，(实质是动态规划）O(nlogn)-O(q) \n4、RMQ标准算法，先规约成LCA，再规约成约束RMQ，O(n)-O(q)\n***\n### 线段树算法###\n用线段树实现的RMQ算法不仅可以查询区间最值,还可以更改某个节点的值\n~~直接套线段树模板~~\n***\n\n### RMQ标准算法\n首先根据原数列，建立笛卡尔树，从而将问题在线性时间内规约为LCA问题。LCA问题可以在线性时间内规约为约束RMQ，也就是数列中任意两个相邻的数的差都是+1或-1的RMQ问题。约束RMQ有O(n)-O(1)的在线解法，故整个算法的时间复杂度为O(n)-O(1)。\n***\n### ST算法\nST算法（Sparse Table），以求最大值为例，d [ i , j ]表示以i 为起点的长度为 2^j 的区间  **[ i , i + 2^j - 1]** ，那么在询问到[a,b]区间的最大值时答案就是 **max (   d [ a , k ],  d [ b - 2^k + 1 , k ]   )**，k是满足 **2^k<=b-a+1** (即长度)的最大的k,即**k= [ ln ( b - a + 1 ) / ln( 2 ) ]**。\n`d[i,j]=max(d[i,j-1],d[i+2^(j-1),j-1])`\n\n```\nvoid rmq_init() /* 预处理 \n{ \n\tfor ( int i = 1; i <= N; i++ )\n\t  \tdp[i][0] = a[i];\n  \tfor ( int j = 1; j <= N; j++ )\n\t  \tfor ( int i = 1; i + (1 << j) - 1 <= N; i++ )\n\t\t  \tdp[i][j] = min( dp[i][j - 1], dp[i + 1 << (j - 1)][j - 1] );\n}\n```\n\n```\nvoid rmq( int l, int r )\n{\n\tint k = log2( r - l + 1 );\n\treturn(min( dp[l][k], dp[r - (l << k) + 1][k] ) );\n}\n```\n \n\n<br/><br/><br/><br/><br/><br/><br/><br/><br/>\n[参考]\n百科 <https://baike.baidu.com/item/RQM/9736833>\nOIWIKI <https://oi-wiki.org/ds/sparse-table/#rmq>\nrqm算法的ST实现 <https://www.cnblogs.com/YSFAC/p/7189571.html>","tags":["笔记"]}]