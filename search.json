[{"title":"RQM算法","url":"/2019/03/10/RQM算法/","content":"### 定义\nRMQ (Range Minimum/Maximum Query)问题是求区间最值的问题。\n***\n### 主要方法   `均为在线算法`\n1、朴素（即搜索），O(n)-O(qn) \n2、线段树，O(n)-O(qlogn) \n3、ST，(实质是动态规划）O(nlogn)-O(q) \n4、RMQ标准算法，先规约成LCA，再规约成约束RMQ，O(n)-O(q)\n***\n### 线段树算法###\n用线段树实现的RMQ算法不仅可以查询区间最值,还可以更改某个节点的值\n~~直接套线段树模板~~\n***\n\n### RMQ标准算法\n首先根据原数列，建立笛卡尔树，从而将问题在线性时间内规约为LCA问题。LCA问题可以在线性时间内规约为约束RMQ，也就是数列中任意两个相邻的数的差都是+1或-1的RMQ问题。约束RMQ有O(n)-O(1)的在线解法，故整个算法的时间复杂度为O(n)-O(1)。\n***\n### ST算法\nST算法（Sparse Table），以求最大值为例，d [ i , j ]表示以i 为起点的长度为 2^j 的区间  **[ i , i + 2^j - 1]** ，那么在询问到[a,b]区间的最大值时答案就是 **max (   d [ a , k ],  d [ b - 2^k + 1 , k ]   )**，k是满足 **2^k<=b-a+1** (即长度)的最大的k,即**k= [ ln ( b - a + 1 ) / ln( 2 ) ]**。\n`d[i,j]=max(d[i,j-1],d[i+2^(j-1),j-1])`\n\n```\nvoid rmq_init() /* 预处理 \n{ \n\tfor ( int i = 1; i <= N; i++ )\n\t  \tdp[i][0] = a[i];\n  \tfor ( int j = 1; j <= N; j++ )\n\t  \tfor ( int i = 1; i + (1 << j) - 1 <= N; i++ )\n\t\t  \tdp[i][j] = min( dp[i][j - 1], dp[i + 1 << (j - 1)][j - 1] );\n}\n```\n\n```\nvoid rmq( int l, int r )\n{\n\tint k = log2( r - l + 1 );\n\treturn(min( dp[l][k], dp[r - (l << k) + 1][k] ) );\n}\n```\n \n\n<br/><br/><br/><br/><br/><br/><br/><br/><br/>\n[参考]\n百科 <https://baike.baidu.com/item/RQM/9736833>\nOIWIKI <https://oi-wiki.org/ds/sparse-table/#rmq>\nrqm算法的ST实现 <https://www.cnblogs.com/YSFAC/p/7189571.html>","tags":["笔记"]}]